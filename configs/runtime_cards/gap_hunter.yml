# Runtime Card: Gap Hunter
# ==========================
# QA Worker: Gap detection between spec and implementation
# Classification: CRITICAL (failure blocks QA)
#
# Used by: QAMasterOrchestrator._execute_worker("gap_hunter")
# Reference: qa_master_orchestrator.py, L5_workers_qa_cerebros.yaml

agent_id: gap_hunter
tier: L5_WORKER
classification: CRITICAL

# Persona for CrewAI agent
role: "Implementation Gap Detector"
goal: "Detect gaps between specifications (RF/INV/EDGE) and actual implementation to ensure complete requirement coverage"
backstory: |
  You are an expert at detecting gaps between what was specified and what was implemented.
  Your role is to systematically compare the requirements (RF), invariants (INV), and
  edge cases (EDGE) from the spec against the actual code implementation.

  You focus on:
  - Missing functionality (RF not implemented)
  - Unenforced invariants (INV not checked in code)
  - Unhandled edge cases (EDGE not covered)
  - Incomplete implementations (partial coverage)
  - Specification ambiguities causing gaps

  For each gap found, you provide:
  - The specific requirement/invariant/edge case not covered
  - Where in the code it should be implemented
  - A suggestion for how to close the gap

  Your findings are CRITICAL - gaps in requirement coverage can cause serious issues.

# Task configuration
task_config:
  max_iterations: 5
  timeout_seconds: 300
  output_format: structured

# Input requirements
input_requirements:
  - deliverables: "List of files to analyze"
  - requirements: "List of functional requirements (RF)"
  - invariants: "List of invariants (INV)"
  - edge_cases: "List of edge cases (EDGE)"

# Output schema
output_schema:
  gaps:
    type: list
    items:
      gap_type: "MISSING_RF | UNENFORCED_INV | UNHANDLED_EDGE | INCOMPLETE"
      spec_id: "string (e.g., RF-001, INV-002, EDGE-003)"
      spec_description: "string"
      severity: "CRITICAL | HIGH | MEDIUM"
      affected_file: "string"
      suggested_location: "file:line"
      fix_suggestion: "string"
  coverage:
    rf_covered: integer
    rf_total: integer
    inv_covered: integer
    inv_total: integer
    edge_covered: integer
    edge_total: integer
  summary:
    type: string
  passed:
    type: boolean

# Stacks to use
stacks:
  - got
  - reflexion
  - qdrant_hybrid
  - graphiti
  - langfuse

# =============================================================================
# F2-001: LETTA MEMORY AWARENESS (2026-02-01)
# =============================================================================
letta_memory:
  enabled: true
  agent_id: "gap_hunter"
  segments:
    - "gap_patterns"       # Common types of gaps found
    - "spec_ambiguities"   # Patterns that cause gaps
    - "coverage_baselines" # What good coverage looks like
  awareness_prompt: |
    MEMÓRIA PERSISTENTE: Você tem acesso a gaps encontrados anteriormente via Letta.
    Use padrões de gaps comuns para saber onde procurar.
    Especificações ambíguas anteriores informam o que validar.

# =============================================================================
# F4-001: SQUAD MEMORY INTEGRATION (2026-02-01)
# =============================================================================
squad_memory:
  enabled: true
  squad_id: "qa_squad"
  role: "worker"
  squad_lead: "qa_master"

  readable_segments:
    - "code_quality_patterns"
    - "common_bugs"
    - "edge_cases_catalog"

  submittable_findings:
    - "gap_pattern"
    - "spec_ambiguity"
    - "coverage_issue"

  awareness_prompt: |
    SQUAD MEMORY: Voce faz parte do qa_squad liderado por qa_master.
    Use os padroes de gaps catalogados pelo squad para saber onde procurar.
    Suas descobertas de gaps criticos serao enviadas ao squad lead automaticamente.


# =============================================================================
# RAG STACKS INTEGRATION (2026-02-01)
# =============================================================================
# RAG stacks for gap detection between spec and implementation
rag_stacks:
  self_rag:
    enabled: true
    priority: 1
    use_cases:
      - "Retrieve gap detection patterns"
      - "Find coverage validation examples"
      - "Query requirement tracing methods"
    parameters:
      critique_response: true
      min_confidence: 0.8  # High confidence for critical role

  graphrag:
    enabled: true
    priority: 2
    use_cases:
      - "Map requirement to implementation"
      - "Trace RF/INV/EDGE coverage"
      - "Understand dependency chains"
    parameters:
      include_reasoning_steps: true
      top_k: 10

  corrective_rag:
    enabled: true
    priority: 3
    use_cases:
      - "Validate spec compliance"
      - "Identify incomplete implementations"
      - "Check invariant enforcement"
    parameters:
      enable_web_fallback: false
      quality_threshold: 0.75

  colbert:
    enabled: true
    priority: 4
    use_cases:
      - "Find specific RF implementations"
      - "Match INV validation code"
      - "Locate EDGE handling"
    parameters:
      top_k: 10

  qdrant_hybrid:
    enabled: true
    priority: 5
    use_cases:
      - "Search spec documentation"
      - "General coverage search"
    parameters:
      collection_name: "specs"
      top_k: 5

  memo_rag:
    enabled: false
    reason: "Worker receives context from squad memory"

  raptor_rag:
    enabled: false
    reason: "Hierarchical search not needed for gap detection"

  awareness_prompt: |
    RAG STACKS: Voce tem acesso a 5 RAG stacks para deteccao de gaps.
    PRIORIDADE: Self-RAG > GraphRAG > Corrective > ColBERT > Qdrant
    Use Self-RAG para buscar padroes de deteccao de alta qualidade.
    Use GraphRAG para mapear requisitos para implementacao.
    GAP HUNTER (CRITICAL): sua funcao e CRITICA - gaps causam problemas serios.

# =============================================================================
# GRAPH STACKS INTEGRATION (2026-02-01)
# =============================================================================
# ALL 6 graph stacks configured for this agent with role-specific operations.
# Access via GraphStackOrchestrator with FAIL-CLOSED pattern.
graph_stacks:
  # FalkorDB - Knowledge graph for evidence and relationships
  falkordb_enabled: true
  falkordb_operations:
    - "traverse"
    - "execute_optimized"

  # Neo4j Enhanced - Vector search and GDS algorithms
  neo4j_enabled: true
  neo4j_operations:
    - "similarity_search"
    - "create_vector_index"

  # Neo4j Algorithms - PageRank, community detection, clustering
  neo4j_algorithms_enabled: true
  neo4j_algorithms_operations:
    - "run_pagerank"
    - "detect_communities"
    - "claim_clustering"

  # Neo4j Analytics - Advanced claim/source analysis
  neo4j_analytics_enabled: true
  neo4j_analytics_operations:
    - "trace_claim_propagation"
    - "get_claim_verification_chain"
    - "analyze_source_credibility"

  # GoT Enhanced - Multi-path reasoning and thought graphs
  got_enabled: true
  got_operations:
    - "analyze_multi_perspective"
    - "build_reasoning_graph"
    - "aggregate_thoughts"

  # Graphiti - Temporal knowledge graph for facts over time
  graphiti_enabled: true
  graphiti_operations:
    - "query_temporal"
    - "get_fact_history"
    - "get_active_facts"
